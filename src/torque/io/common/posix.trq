(ns torque.io.common.posix
  (:require
    [torque.ffi :as ffi])
  (:use
    [torque.io.common.types]))

(def libc (ffi/so "c"))
(def proc (ffi/so))

;; basic file descriptor API

(ffi/defimport -open   libc open :sint32 [:string :sint32])
(ffi/defimport -create libc open :sint32 [:string :sint32 :sint32])
(ffi/defimport -close  libc close :sint32 [:sint32])

(ffi/defimport -read  libc read :uint64 [:sint32 :ptr :uint64])
(ffi/defimport -pread libc pread :uint64 [:sint32 :ptr :uint64 :uint64])
(ffi/defimport -write libc write :uint64 [:sint32 :ptr :uint64])

(ffi/defimport -pathconf libc pathconf :sint64 [:string :sint32])

#?(:os/linux
   (do
     (ffi/defimport -stat  libc __xstat :sint32 [:sint32 :string :ptr])
     (ffi/defimport -lstat libc __lxstat :sint32 [:sint32 :string :ptr]))
   :os/darwin
   (do
     (ffi/defimport -stat  libc stat$64 :sint32 [:string :ptr])
     (ffi/defimport -lstat libc lstat$64 :sint32 [:string :ptr]))
   :default
   (do
     (ffi/defimport -stat  libc stat :sint32 [:string :ptr])
     (ffi/defimport -lstat libc lstat :sint32 [:string :ptr])))

(ffi/defimport -opendir  libc opendir :ptr [:string])
(ffi/defimport -closedir libc closedir :sint32 [:ptr])
(ffi/defimport -readdir  libc readdir :ptr [:ptr])

(ffi/defimport -getcwd libc getcwd :ptr [:ptr :uint64])

(ffi/defimport memcpy libc memcpy :ptr [:ptr :ptr :sint64])

;; directory API

(def DT_UNKNOWN 0)
(def DT_FIFO    1)
(def DT_CHR     2)
(def DT_DIR     4)
(def DT_BLK     6)
(def DT_REG     8)
(def DT_LNK     10)
(def DT_SOCK    12)
(def DT_WHT     14)

(def O_RDONLY 0)
(def O_WRONLY 1)
(def O_RDWR   2)

(def path-delimiter  "/")
(def max-path-length 1024)

;; TODO: these should be generated by the compiler eventually

(def dirent-size 
  #?(:os/linux  280
     :os/darwin 1048))

(defn get-dirent-type [b]
  (get-uint8 b #?(:os/linux 18 :os/darwin 20)))

(defn get-dirent-name [b max-name-len]
  (get-string b #?(:os/linux 19 :os/darwin 21) max-name-len))

(def stat-size 144)

(defn get-stat-st-size [b]
  (get-int64 b 96))

(defn ^:private entry-type [n]
  (cond
    (== DT_UNKNOWN n) :unknown
    (== DT_FIFO    n) :fifo
    (== DT_CHR     n) :char
    (== DT_DIR     n) :directory
    (== DT_BLK     n) :block
    (== DT_REG     n) :file
    (== DT_LNK     n) :link
    (== DT_SOCK    n) :socket
    (== DT_WHT     n) :wht))

(defn directory-entry [b max-name-len]
  (let [type   (entry-type (get-dirent-type b))
        name   (get-dirent-name b max-name-len)]
    (new DirectoryEntry type name)))

(deftype FileDescriptor [fd]
  IResource
  (-dispose [this]
    (when (> fd 0)
      (-close fd)
      (set! this fd -1)
      nil)))

(deftype Directory [path handle]
  IResource
  (-dispose [_]
    (when handle
      (-closedir handle)))
  IPointerTarget
  (-intptr [_]
    handle))

(defn ^:private max-entry-length [dir]
  (-pathconf (. dir path) 4))

(defn ^:private read-entry [dir max-entry-len]
  (let [p (-readdir (intptr dir))]
    (if-not (== p 0)
      (let [buffer (make-binary dirent-size)
            _      (memcpy (intptr buffer) p dirent-size)
            entry  (directory-entry buffer max-entry-len)]
        entry)
      (when (ffi/system-error?)
        (ffi/throw-system-error {})))))

(defn ^:private read-entries [dir]
 (let [max-entry-len (max-entry-length dir)]
   (loop [out []]
     (if-let [entry (read-entry dir max-entry-len)]
       (recur (conj out entry))
       out))))

(defn readdir [path]
  (if-let [p (and path (ffi/not-null (-opendir path)))]
    (with-resource [dir (new Directory path p)]
      (read-entries dir))
    (if (ffi/enoent?)
      []
      (ffi/throw-system-error {:path "path"}))))

(defn cwd []
  (let [b (make-binary max-path-length)]
    (-getcwd (intptr b) max-path-length)
    (get-string b 0 max-path-length)))

(defn ^:private stat [path flags]
  (if (string? path)
    (let [stat-fn (fn stat-impl [path p]
                    (if (= (first flags) :resolve-links)
                      (-lstat 0 path p)
                      (-stat 0 path p)))
          buffer  (make-binary stat-size)
          ret     (stat-fn path (intptr buffer))]
      (when (zero? ret)
        buffer))))

(defn exists? [path & flags]
  (if-let [exists? (stat path flags)]
    true
    (if (ffi/enoent?)
      false
      (ffi/throw-system-error {:path path}))))

(defn ^:private throw-unknown-access [flag]
  (throw
    (ex-info (str "Unknonwn access flag: " flag)
      {:flag flag})))

(defn ^:private parse-access [flag]
  (cond
    (= flag :read)  O_RDONLY
    (= flag :write) O_WRONLY
    (= flag :rw)    O_RDWR
    :else (throw-unknown-access flag)))

(defn ^:private parse-oflags [init flags]
  (reduce
    (fn [out flag]
      (bit-or
        out
        (cond
          :else 0)))
    init
    flags))

(defn open [path access flags]
  (when (string? path)
    (let [flags (parse-oflags (parse-access access) flags)
          fd    (-open path flags)]
      (if (== fd -1)
        (ffi/throw-system-error {:path path})
        (new FileDescriptor fd)))))

(defn throw-unexpected-return [op code]
  (throw
    (ex-info (str "A posix function returned an unexpected value: " code)
      {:op   :read
       :code code})))

(defn ^:private read-result [bytes-read]
  (cond
    (> bytes-read 0)   bytes-read
    (== bytes-read -1) (ffi/throw-system-error)
    (== bytes-read 0)  :eof
    :else (throw-unexpected-return :read bytes-read)))

(defn read
  ([fd bytes buffer]
   (if fd
     (-> (-read (. fd fd) (intptr buffer) bytes)
         (read-result))))
  ([fd offset bytes buffer]
   (if fd
     (-> (-pread (. fd fd) (intptr buffer) bytes offset)
         (read-result)))))

(defn size [fd]
  (if-let [stats (stat fd)]
    (get-stat-st-size stats)
    (ffi/throw-system-error {:fd (. fd fd)})))

(def stdin  (new FileDescriptor 0))
(def stdout (new FileDescriptor 1))
(def stderr (new FileDescriptor 2))
